name: EPG-MX

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 7 * * *' # daily 07:00 UTC

concurrency:
  group: epg-mx
  cancel-in-progress: true

jobs:
  mx:
    runs-on: ubuntu-latest
    timeout-minutes: 300

    env:
      MX_SEARCH_URL: https://iptv-org.github.io/?q=live%20country:MX
      MX_EPG_URLS: >-
        https://epgshare01.online/epgshare01/epg_ripper_US1.xml.gz
        https://epgshare01.online/epgshare01/epg_ripper_US_LOCALS2.xml.gz
        https://epgshare01.online/epgshare01/epg_ripper_MX1.xml.gz
      M3U_URL: ${{ secrets.M3U_URL }}
      HEADLESS: 'true'
      MAX_CHANNELS: '0'
      PER_PAGE_DELAY_MS: '150'
      NAV_TIMEOUT_MS: '30000'
      PROBE_TIMEOUT_MS: '5000'
      FUZZY_MIN: '0.45'
      LOG_UNMATCHED: '1'
      INGEST_PROGRAMS: '1'          # set to '0' to skip program ingestion
      PROGRAMS_HOURS_AHEAD: '36'
      SUPABASE_SCHEMA: public
      SUPABASE_TABLE: mx_channels    # streams table
      PROGRAMS_TABLE: epg_programs   # programs table
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
      NORDVPN_TOKEN: ${{ secrets.NORDVPN_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Node deps (Playwright, Supabase, Saxes)
        shell: bash
        run: |
          set -euo pipefail
          npm i --no-save playwright saxes @supabase/supabase-js
          npx playwright install --with-deps chromium

      - name: Install NordVPN CLI
        if: ${{ env.NORDVPN_TOKEN != '' }}
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y curl gnupg expect
          curl -sSf https://repo.nordvpn.com/gpg/nordvpn_public.asc \
            | sudo gpg --dearmor -o /usr/share/keyrings/nordvpn-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/nordvpn-archive-keyring.gpg] https://repo.nordvpn.com/deb/nordvpn/debian stable main" \
            | sudo tee /etc/apt/sources.list.d/nordvpn.list
          sudo apt-get update
          sudo apt-get install -y nordvpn
          sudo systemctl enable --now nordvpnd || true

      - name: Make non-interactive nordvpn wrapper
        if: ${{ env.NORDVPN_TOKEN != '' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts
          cat > scripts/nordvpn.exp <<'EXP'
          #!/usr/bin/expect -f
          set timeout 180
          if {$argc < 1} { exit 2 }
          log_user 1
          spawn -noecho sudo nordvpn {*}$argv
          expect {
            -re "(?i)\\(y/n\\)\\s*$"        { send -- "n\r"; exp_continue }
            -re "(?i)yes/no\\)?\\s*$"       { send -- "no\r"; exp_continue }
            -re "(?i)Would you like.*\\(y/n\\)" { send -- "n\r"; exp_continue }
            -re "(?i)Do you allow.*\\(y/n\\)"   { send -- "n\r"; exp_continue }
            -re "(?i)Status:\\s*Connected"  { }
            -re "(?i)Connected"             { }
            timeout                         { exit 124 }
            eof                             { }
          }
          catch wait result
          if {[lindex $result 3] == 0} { exit 0 } else { exit [lindex $result 3] }
          EXP
          chmod +x scripts/nordvpn.exp

      - name: Write scraper script
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts out/mx
          cat > scripts/mx-scrape-and-match.mjs <<'EOF'
          import { chromium } from 'playwright';
          import { createGunzip } from 'node:zlib';
          import { Readable } from 'node:stream';
          import fs from 'node:fs/promises';
          import path from 'node:path';
          import { setTimeout as delay } from 'node:timers/promises';
          import { createClient } from '@supabase/supabase-js';
          import { SaxesParser } from 'saxes';

          const SEARCH_URL = process.env.MX_SEARCH_URL || '';
          const EPG_URLS = (process.env.MX_EPG_URLS || '').trim().split(/\s+/).filter(Boolean);
          const M3U_URL = (process.env.M3U_URL || '').trim();

          const HEADLESS = (process.env.HEADLESS ?? 'true') !== 'false';
          const MAX_CHANNELS = Number(process.env.MAX_CHANNELS || '0');
          const PER_PAGE_DELAY_MS = Number(process.env.PER_PAGE_DELAY_MS || '150');
          const NAV_TIMEOUT_MS = Number(process.env.NAV_TIMEOUT_MS || '30000');
          const PROBE_TIMEOUT_MS = Number(process.env.PROBE_TIMEOUT_MS || '5000');
          const FUZZY_MIN = Number(process.env.FUZZY_MIN || '0.45');
          const LOG_UNMATCHED = process.env.LOG_UNMATCHED === '1';

          const INGEST_PROGRAMS = process.env.INGEST_PROGRAMS === '1';
          const PROGRAMS_HOURS_AHEAD = Number(process.env.PROGRAMS_HOURS_AHEAD || '36');

          const SUPABASE_URL = process.env.SUPABASE_URL || '';
          const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY || '';
          const SUPABASE_SCHEMA = process.env.SUPABASE_SCHEMA || 'public';
          const SUPABASE_TABLE = process.env.SUPABASE_TABLE || 'mx_channels';
          const PROGRAMS_TABLE = process.env.PROGRAMS_TABLE || 'epg_programs';

          // ---------- helpers ----------
          const sleep = ms => new Promise(r => setTimeout(r, ms));
          async function fetchRetry(url, init={}, tries=3) {
            let last;
            for (let i=1;i<=tries;i++){
              try {
                const r = await fetch(url, init);
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                return r;
              } catch (e) {
                last = e;
                if (i<tries) await sleep(1000*i);
              }
            }
            throw last;
          }

          function stripAccents(s){return String(s).normalize('NFD').replace(/\p{Diacritic}+/gu,'');}
          function normalizeNumerals(s){const map={uno:'1',dos:'2',tres:'3',cuatro:'4',cinco:'5',seis:'6',siete:'7',ocho:'8',nueve:'9',diez:'10',once:'11',doce:'12',trece:'13'};return String(s).replace(/\b(uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez|once|doce|trece)\b/gi,m=>map[m.toLowerCase()]);}
          function dropTimeshift(s){return String(s).replace(/(?:[-+]\s*\d+\s*(?:h|hora|horas)\b)/ig,'').replace(/\b\d+\s*horas?\b/ig,'').replace(/\(\s*\d+\s*horas?\s*\)/ig,'').replace(/\btime\s*shift\b/ig,'').replace(/\s{2,}/g,' ').trim();}
          function stripLeadingCanal(s){return String(s).replace(/^\s*canal[\s._-]+/i,'');}
          function stripCountryTail(s){return String(s).replace(/(\.(mx|us)|\s+\(?mx\)?|\s+m[eé]xico|\s+usa|\s+eeuu)\s*$/i,'').trim();}
          const STOP=new Set(['canal','tv','television','hd','sd','mx','mexico','méxico','hora','horas','us','usa','eeuu']);
          function tokensOf(s){if(!s)return[];let p=stripAccents(normalizeNumerals(String(s).toLowerCase()));p=dropTimeshift(p);p=stripCountryTail(p);p=p.replace(/&/g,' and ').replace(/[^a-z0-9]+/g,' ').trim();return p.split(/\s+/).filter(t=>t&&!STOP.has(t));}
          function keyOf(s){return Array.from(new Set(tokensOf(s))).sort().join(' ');}
          function expandNameVariants(s){if(!s)return[];const out=new Set();const orig=String(s).trim();const noCanal=stripLeadingCanal(orig);const flat=x=>x.replace(/[._(),]+/g,' ').replace(/\s+/g,' ').trim();const noTS=dropTimeshift(noCanal);const noTail=stripCountryTail(noTS);[orig,noCanal,noTS,noTail,flat(orig),flat(noCanal),flat(noTS),flat(noTail)].forEach(v=>{if(v)out.add(v);});return[...out];}
          function containsMexicoTag(s){const t=stripAccents(String(s).toLowerCase()).replace(/[^a-z0-9]+/g,' ').trim();const parts=t.split(/\s+/);return parts.includes('mexico')||parts.includes('mx')||/\.mx\b/i.test(String(s));}
          function uniqBy(arr,keyFn){const m=new Map();for(const x of arr){const k=keyFn(x);if(!m.has(k))m.set(k,x);}return[...m.values()];}
          function jaccard(aTokens,bTokens){const A=new Set(aTokens),B=new Set(bTokens);let inter=0;for(const t of A)if(B.has(t))inter++;return inter/(A.size+B.size-inter||1);}

          // ---------- optional M3U parsing (tvg-id) ----------
          async function parseM3U(url){
            if(!url) return {byUrl:new Map(), byNameKey:new Map()};
            const res = await fetchRetry(url, {headers:{'user-agent':'curl/8'}});
            const txt = await res.text();
            const byUrl = new Map();
            const byNameKey = new Map();
            const lines = txt.split(/\r?\n/);
            let curMeta = null;
            const attrRx = /(\w[\w-]*)="([^"]*)"/g;
            for (let i=0;i<lines.length;i++){
              const line = lines[i].trim();
              if (!line) continue;
              if (line.startsWith('#EXTINF')) {
                curMeta = { tvgId:null, name:null };
                let m;
                while ((m = attrRx.exec(line))) {
                  const k = m[1].toLowerCase();
                  const v = m[2];
                  if (k === 'tvg-id') curMeta.tvgId = v;
                }
                const comma = line.indexOf(',');
                if (comma !== -1) {
                  const title = line.slice(comma+1).trim();
                  if (title) curMeta.name = title;
                }
              } else if (!line.startsWith('#')) {
                const urlLine = line;
                if (curMeta && (curMeta.tvgId || curMeta.name)) {
                  if (curMeta.tvgId) byUrl.set(urlLine, curMeta.tvgId);
                  if (curMeta.name) byNameKey.set(keyOf(curMeta.name), curMeta.tvgId || null);
                }
                curMeta = null;
              }
            }
            return { byUrl, byNameKey };
          }

          // ---------- scraping ----------
          async function collectChannelPages(browser){
            const page=await browser.newPage();
            page.setDefaultTimeout(NAV_TIMEOUT_MS);
            await page.goto(SEARCH_URL,{waitUntil:'domcontentloaded'});
            await page.waitForSelector('a[href*="/channels/"]',{timeout:15000}).catch(()=>{});
            await page.waitForTimeout(800);
            let items=await page.$$eval('a[href*="/channels/"]',as=>{
              const out=[];
              for(const a of as){
                const href=a.getAttribute('href')||'';
                if(!href.includes('/channels/'))continue;
                const url=new URL(href,location.href).href;
                const name=(a.textContent||'').trim();
                out.push({url,name});
              }
              const m=new Map();for(const it of out)if(!m.has(it.url))m.set(it.url,it);return[...m.values()];
            });
            items=items.filter(i=>i.name&&i.url);
            items=uniqBy(items,x=>x.url);
            if(MAX_CHANNELS>0&&items.length>MAX_CHANNELS)items=items.slice(0,MAX_CHANNELS);
            await page.close();
            return items.map(i=>({...i,nameKey:keyOf(i.name)}));
          }
          async function scrapeChannel(browser,link){
            const page=await browser.newPage();
            page.setDefaultTimeout(NAV_TIMEOUT_MS);
            try{
              await page.goto(link.url,{waitUntil:'domcontentloaded'});
              await page.waitForTimeout(400);
              const tab=await page.$('text=Streams'); if(tab){await tab.click().catch(()=>{}); await page.waitForTimeout(300);}
              let anchors=await page.$$eval('a[href*=".m3u8"]',els=>els.map(e=>({url:e.href,text:(e.textContent||'').trim()})));
              if(!anchors.length){
                const html=await page.content();
                const rx=/https?:\/\/[^\s"'<>]+\.m3u8[^\s"'<>]*/gi;
                const set=new Set(); let m; while((m=rx.exec(html))) set.add(m[0]);
                anchors=[...set].map(u=>({url:u,text:''}));
              }
              anchors=uniqBy(anchors.filter(a=>/^https?:\/\//i.test(a.url)),a=>a.url);
              return anchors.map(a=>({url:a.url,quality:(a.text.match(/\b(1080p|720p|480p|360p|HD|SD)\b/i)||[])[0]||null}));
            }catch(e){console.error(`Error scraping ${link.url}: ${e.message}`);return[];}
            finally{await page.close();}
          }
          async function scrapeAll(browser,links){
            const out=[];
            for(const lnk of links){
              const streams=await scrapeChannel(browser,lnk);
              if(streams.length){out.push({channelName:lnk.name,channelNameKey:lnk.nameKey,streams});}
              await delay(PER_PAGE_DELAY_MS);
            }
            return out;
          }
          async function probeM3U8(url){
            const ac=new AbortController();
            const t=setTimeout(()=>ac.abort(),PROBE_TIMEOUT_MS);
            try{
              const r=await fetch(url,{method:'GET',headers:{'user-agent':'Mozilla/5.0','accept':'application/vnd.apple.mpegurl,text/plain,*/*'},signal:ac.signal});
              if(!r.ok) return false;
              const txt=await r.text();
              return txt.includes('#EXTM3U');
            }catch{return false;} finally{clearTimeout(t);}
          }

          // ---------- EPG parsing ----------
          function isMexicoEntry(id,names){ if(!id&&(!names||!names.length))return false; if(id&&containsMexicoTag(id))return true; for(const n of (names||[])) if(containsMexicoTag(n)) return true; return false; }
          function parseXmltvTime(s){
            // XMLTV usually YYYYMMDDHHMMSS Z or no tz. We'll parse simply.
            // Accept YYYYMMDDHHMMSS (+/-)HHMM optional.
            const m = String(s).match(/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(?:\s*([+-]\d{4}|Z))?/);
            if(!m) return null;
            const [_,Y,Mo,D,H,Mi,S,off] = m;
            const base = `${Y}-${Mo}-${D}T${H}:${Mi}:${S}`;
            if (!off || off==='Z') return new Date(base+'Z'); // assume UTC
            const sign = off.startsWith('-') ? -1 : 1;
            const hh = Number(off.slice(1,3)), mm=Number(off.slice(3,5));
            const tzMin = sign*(hh*60+mm);
            // interpret base as UTC then subtract offset to get UTC time
            const ms = Date.parse(base+'Z') - tzMin*60*1000;
            return new Date(ms);
          }

          async function parseAllEpg(urls, nameMapOut, entriesOut, programsCollector){
            const agg={idTo:new Map(), nameMap:new Map(), programmesSeen:new Set()};
            for (const url of urls) {
              console.log(`Downloading EPG (stream)… ${url}`);
              const res = await fetchRetry(url);
              const gunzip=createGunzip();
              const src=Readable.fromWeb(res.body);
              const decoder=new TextDecoder('utf-8');
              const parser=new SaxesParser({xmlns:false});

              const MAX_NAME_CHARS=1024, MAX_NAMES_PER_CH=24, MAX_VARIANTS=64;
              let cur=null,inDisp=false,dispChunks=[],dispLen=0,dispTruncated=false;

              // program state (only build if needed)
              let prog=null, inTitle=false, inSub=false, inDesc=false, inCat=false, inUrl=false, inEpisode=false, inIcon=false, curTextBuf='';

              const keepWindowTo = new Date(Date.now() + PROGRAMS_HOURS_AHEAD*3600*1000);

              parser.on('opentag', (tag)=>{
                const nm = String(tag.name).toLowerCase();
                if (nm==='channel') { cur={id:tag.attributes?.id?String(tag.attributes.id):'', namesRaw:[]}; }
                else if (nm==='display-name' && cur) { inDisp=true; dispChunks=[]; dispLen=0; dispTruncated=false; }
                else if (nm==='programme') {
                  if (!INGEST_PROGRAMS) return;
                  const cid = String(tag.attributes?.channel || '');
                  const st = parseXmltvTime(tag.attributes?.start || '');
                  const en = parseXmltvTime(tag.attributes?.stop || '');
                  if (cid && st && en && st <= keepWindowTo) {
                    prog = { channel_id: cid, start_ts: st.toISOString(), stop_ts: en.toISOString(), title:null, sub_title:null, summary:null, categories:[], program_url:null, episode_num_xmltv:null, icon_url:null, extras:{} };
                  } else { prog = null; }
                } else if (nm==='title') { if (prog){ inTitle=true; curTextBuf=''; } }
                else if (nm==='sub-title') { if (prog){ inSub=true; curTextBuf=''; } }
                else if (nm==='desc') { if (prog){ inDesc=true; curTextBuf=''; } }
                else if (nm==='category') { if (prog){ inCat=true; curTextBuf=''; } }
                else if (nm==='url') { if (prog){ inUrl=true; curTextBuf=''; } }
                else if (nm==='episode-num') { if (prog){ inEpisode=true; curTextBuf=''; } }
                else if (nm==='icon') { if (prog){ const u = tag.attributes?.src?String(tag.attributes.src):null; if(u) prog.icon_url=u; } }
              });

              parser.on('text', (t)=>{
                if (inDisp && cur && t && !dispTruncated) {
                  let chunk=String(t);
                  if (chunk.length > MAX_NAME_CHARS) chunk = chunk.slice(0, MAX_NAME_CHARS);
                  const remain = MAX_NAME_CHARS - dispLen;
                  if (remain <= 0) { dispTruncated = true; return; }
                  if (chunk.length > remain) { chunk = chunk.slice(0, remain); dispTruncated = true; }
                  if (chunk) { dispChunks.push(chunk); dispLen += chunk.length; }
                }
                if (!prog) return;
                if (inTitle||inSub||inDesc||inCat||inUrl||inEpisode) curTextBuf += t;
              });

              parser.on('closetag', (nameRaw)=>{
                const nm = String(nameRaw).toLowerCase();
                if (nm==='display-name' && cur) {
                  if (cur.namesRaw.length<MAX_NAMES_PER_CH) {
                    const txt = dispChunks.length ? dispChunks.join('') : '';
                    const clean = txt.trim();
                    if (clean) cur.namesRaw.push(clean);
                  }
                  inDisp=false; dispChunks=[]; dispLen=0; dispTruncated=false;
                } else if (nm==='channel' && cur) {
                  const id = cur.id || '';
                  const keep = /_MX/i.test(url) ? true : isMexicoEntry(id, cur.namesRaw);
                  if (keep) {
                    const names = new Set();
                    for (const n of cur.namesRaw) for (const v of expandNameVariants(n)) if (v) names.add(v);
                    for (const v of expandNameVariants(id)) if (v) names.add(v);
                    const limited=[]; for (const v of names){ limited.push(v); if(limited.length>=MAX_VARIANTS) break; }
                    let entry = agg.idTo.get(id);
                    if (!entry) { entry = { id, names:[], tokenSet:new Set() }; agg.idTo.set(id, entry); }
                    entry.names = Array.from(new Set(entry.names.concat(limited))).slice(0,MAX_VARIANTS);
                    entry.tokenSet = new Set(); for (const nm2 of entry.names) for (const tok of tokensOf(nm2)) entry.tokenSet.add(tok);
                    for (const n of entry.names){ const k = keyOf(n); if(k && !agg.nameMap.has(k)) agg.nameMap.set(k, entry); }
                  }
                  cur=null; inDisp=false; dispChunks=[]; dispLen=0; dispTruncated=false;
                } else if (nm==='title') { if (prog){ prog.title = (curTextBuf||'').trim() || prog.title; inTitle=false; } }
                else if (nm==='sub-title') { if (prog){ prog.sub_title = (curTextBuf||'').trim() || prog.sub_title; inSub=false; } }
                else if (nm==='desc') { if (prog){ prog.summary = (curTextBuf||'').trim() || prog.summary; inDesc=false; } }
                else if (nm==='category') { if (prog){ const v=(curTextBuf||'').trim(); if(v) prog.categories.push(v); inCat=false; } }
                else if (nm==='url') { if (prog){ const v=(curTextBuf||'').trim(); if(v) prog.program_url=v; inUrl=false; } }
                else if (nm==='episode-num') { if (prog){ const v=(curTextBuf||'').trim(); if(v) prog.episode_num_xmltv=v; inEpisode=false; } }
                else if (nm==='programme') {
                  if (prog) programsCollector.push(prog);
                  prog=null;
                }
              });

              await new Promise((resolve, reject)=>{
                src.on('error', reject);
                gunzip.on('error', reject);
                gunzip.on('data', (chunk)=>{ const text = decoder.decode(chunk, {stream:true}); if (text) parser.write(text); });
                gunzip.on('end', ()=>{ parser.write(decoder.decode(new Uint8Array(), {stream:false})); parser.close(); resolve(); });
                src.pipe(gunzip);
              });
            }
            const kept = new Set([...agg.nameMap.values()]);
            for (const e of kept) entriesOut.push(e);
            for (const [k,v] of agg.nameMap) nameMapOut.set(k,v);
          }

          function findMatch(channelName, nameKey, nameMap, entries){
            const exact=nameMap.get(nameKey); if(exact) return {entry:exact, score:1, method:'exact'};
            const sTokArr=tokensOf(channelName); const sTok=new Set(sTokArr);
            if(sTok.size===1){const [only]=[...sTok]; for(const e of entries) if(e.tokenSet&&e.tokenSet.has(only)) return {entry:e,score:0.99,method:'anchor'};}
            let subsetBest=null, subsetBestSize=Infinity;
            for(const e of entries){const E=e.tokenSet||new Set(); let allIn=true; for(const t of sTok){if(!E.has(t)){allIn=false;break;}} if(allIn&&E.size<subsetBestSize){subsetBest=e;subsetBestSize=E.size;}}
            if(subsetBest) return {entry:subsetBest,score:0.9,method:'subset'};
            let best=null,bestScore=0; for(const e of entries) for(const nm of e.names){const score=jaccard(sTokArr,tokensOf(nm)); if(score>bestScore){bestScore=score;best=e;}}
            if(best&&bestScore>=FUZZY_MIN) return {entry:best,score:bestScore,method:'fuzzy'};
            return {entry:null,score:0,method:'none'};
          }

          async function saveRows(rows){
            if(!SUPABASE_URL||!SUPABASE_SERVICE_KEY){console.log('Supabase env missing; skipped DB upload.'); return;}
            if(!rows.length){console.log('No rows to upload to Supabase.'); return;}
            const supabase=createClient(SUPABASE_URL,SUPABASE_SERVICE_KEY,{auth:{persistSession:false},db:{schema:SUPABASE_SCHEMA}});
            let {error}=await supabase.from(SUPABASE_TABLE).upsert(rows,{onConflict:'stream_url',ignoreDuplicates:false});
            if(error){console.warn(`Upsert failed (${error.code??'no-code'}): ${error.message}`);}
            else {console.log(`DB write OK: ${rows.length} rows`);}
          }

          async function savePrograms(programs){
            if(!INGEST_PROGRAMS) return;
            if(!SUPABASE_URL||!SUPABASE_SERVICE_KEY){console.log('Supabase env missing; skipped program ingest.'); return;}
            if(!programs.length){console.log('No programs to ingest.'); return;}
            const supabase=createClient(SUPABASE_URL,SUPABASE_SERVICE_KEY,{auth:{persistSession:false},db:{schema:SUPABASE_SCHEMA}});
            const batch=500;
            for (let i=0;i<programs.length;i+=batch){
              const slice = programs.slice(i,i+batch).map(p=>({
                channel_id: p.channel_id,
                start_ts: p.start_ts,
                stop_ts: p.stop_ts,
                title: p.title,
                sub_title: p.sub_title,
                summary: p.summary,
                categories: p.categories?.length? p.categories : null,
                program_url: p.program_url,
                icon_url: p.icon_url,
                episode_num_xmltv: p.episode_num_xmltv,
                ingested_at: new Date().toISOString()
              }));
              const { error } = await supabase.from(PROGRAMS_TABLE).insert(slice);
              if (error) { console.warn(`Program insert failed: ${error.message}`); break; }
            }
            console.log(`Program ingest attempted for ${programs.length} rows`);
          }

          async function main(){
            await fs.mkdir('out/mx', {recursive:true});
            const browser=await chromium.launch({headless:HEADLESS});
            try{
              console.log(`Scraping: ${SEARCH_URL}`);
              const links=await collectChannelPages(browser);
              console.log(`Found ${links.length} channel pages.`);
              const scraped=await scrapeAll(browser,links);
              console.log(`Channels with at least one .m3u8 (before probe): ${scraped.length}`);

              for(const row of scraped){
                const tested=[]; for(const s of row.streams){const ok=await probeM3U8(s.url); if(ok)tested.push(s);} row.streams=tested;
              }
              const filtered=scraped.filter(r=>r.streams.length>0);
              console.log(`Channels with at least one WORKING .m3u8: ${filtered.length}`);

              // M3U mapping (optional)
              const m3uMaps = await parseM3U(M3U_URL);
              // EPG parse (multi-files)
              const nameMap=new Map(); const entries=[]; const programs=[];
              await parseAllEpg(EPG_URLS, nameMap, entries, programs);

              console.log(`EPG entries kept (Mexico-related): ${entries.length}`);

              const records=[]; const matchedOnly=[];
              for (const r of filtered) {
                // prefer direct tvg-id -> EPG id if we have it
                let tvgId = null;
                // try url-based M3U match first
                for (const s of r.streams){
                  if (m3uMaps.byUrl.has(s.url)) { tvgId = m3uMaps.byUrl.get(s.url); break; }
                }
                // fallback: name-key based
                if (!tvgId && m3uMaps.byNameKey.has(r.channelNameKey)) tvgId = m3uMaps.byNameKey.get(r.channelNameKey);

                let entry = null, method = 'none';
                if (tvgId) {
                  entry = entries.find(e => e.id === tvgId) || null;
                  method = entry ? 'tvg-id' : 'tvg-id-miss';
                }
                if (!entry) {
                  const m = findMatch(r.channelName, r.channelNameKey, nameMap, entries);
                  entry = m.entry; method = m.method;
                }

                for (const s of r.streams) {
                  const rec = {
                    stream_url: s.url,
                    channel_guess: r.channelName,
                    epg_channel_id: entry ? entry.id : null,
                    epg_display_name: entry ? (entry.names[0] || null) : null,
                    working: true,
                    checked_at: new Date().toISOString(),
                    // some DBs require channel_name NOT NULL
                    channel_name: entry ? (entry.names[0] || r.channelName) : r.channelName
                  };
                  records.push(rec);
                  if (entry) matchedOnly.push({...rec, _match_method: method});
                }
              }

              console.log(`Matched with EPG: ${matchedOnly.length} stream rows (across ${filtered.length} channels).`);

              await fs.writeFile(path.join('out','mx','records.json'), JSON.stringify(records,null,2), 'utf8');
              await fs.writeFile(path.join('out','mx','matches.json'), JSON.stringify(matchedOnly,null,2), 'utf8');

              if (LOG_UNMATCHED) {
                const matchedUrls=new Set(matchedOnly.map(x=>x.stream_url));
                const unmatched=records.filter(x=>!matchedUrls.has(x.stream_url));
                await fs.writeFile(path.join('out','mx','unmatched.json'), JSON.stringify(unmatched,null,2), 'utf8');
                console.log(`Wrote out/mx/unmatched.json with ${unmatched.length} unmatched rows`);
              }

              // Save streams
              await saveRows(records);

              // Save a small sample of programs (for artifact visibility)
              await fs.writeFile(path.join('out','mx','epg_programs_sample.json'), JSON.stringify(programs.slice(0,300), null, 2), 'utf8');
              // Ingest programs (optional)
              await savePrograms(programs);
            } finally {
              await browser.close();
            }
          }

          main().catch((e)=>{ console.error(e); process.exit(1); });
          EOF

      - name: Connect VPN (if token) & verify
        if: ${{ env.NORDVPN_TOKEN != '' }}
        shell: bash
        run: |
          set -euo pipefail
          scripts/nordvpn.exp login --token "$NORDVPN_TOKEN" || true
          scripts/nordvpn.exp set analytics disabled || true
          scripts/nordvpn.exp set technology nordlynx || true
          scripts/nordvpn.exp set firewall off || true
          scripts/nordvpn.exp set killswitch off || true

          attempts=5
          connected=0
          for i in $(seq 1 $attempts); do
            echo "Attempt $i/$attempts: connecting to Mexico..."
            if timeout -k 10s 75s scripts/nordvpn.exp connect Mexico; then
              sleep 2
            fi
            if sudo nordvpn status | grep -qi 'Status: Connected'; then
              echo "VPN Connected."
              connected=1; break
            fi
            echo "Retrying..."
            sudo nordvpn disconnect || true
            sleep 6
          done

          if [ "$connected" -ne 1 ]; then
            echo "Failed to connect to NordVPN Mexico."
            sudo nordvpn status || true
            journalctl -u nordvpnd --no-pager -n 200 || true
            exit 1
          fi

          echo "::group::Egress Check"
          curl -s https://ifconfig.io ; echo
          echo -n "Country: "; curl -s https://ifconfig.io/country || true
          echo "::endgroup::"

      - name: Run MX scrape & match
        shell: bash
        run: |
          set -euo pipefail
          node scripts/mx-scrape-and-match.mjs

      - name: NordVPN disconnect
        if: always() && env.NORDVPN_TOKEN != ''
        shell: bash
        run: |
          set -euo pipefail
          sudo nordvpn disconnect || true
          sudo nordvpn status || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mx-output
          path: |
            out/mx/records.json
            out/mx/matches.json
            out/mx/unmatched.json
            out/mx/epg_programs_sample.json
          if-no-files-found: warn

name: EPG-MX
on:
  workflow_dispatch:
  schedule:
    - cron: "0 7 * * *" # daily 07:00 UTC

jobs:
  mx:
    runs-on: ubuntu-latest
    timeout-minutes: 300
    env:
      MX_SEARCH_URL: https://iptv-org.github.io/?q=live%20country:MX
      MX_EPG_URL: https://epgshare01.online/epgshare01/epg_ripper_MX1.xml.gz
      HEADLESS: "true"
      MAX_CHANNELS: "0"       # set to e.g. 25 for test runs
      PER_PAGE_DELAY_MS: "150"
      NAV_TIMEOUT_MS: "30000"
      PROBE_TIMEOUT_MS: "5000"
      SUPABASE_TABLE: epg_streams
      # Provide these as repo secrets to enable DB upload:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Playwright and deps
        run: |
          npm i --no-save playwright fast-xml-parser @supabase/supabase-js
          npx playwright install --with-deps chromium

      - name: Write script
        run: |
          mkdir -p scripts out/mx
          cat > scripts/mx-scrape-and-match.mjs <<'EOF'
# All lines in the script are indented correctly
# Scrape iptv-org.github.io for live MX channels (no JSON APIs), pull .m3u8s,
# download EPGShare MX XML, match by display-name, probe stream, write artifact,
# optional Supabase upsert.

import { chromium } from 'playwright';
import { XMLParser } from 'fast-xml-parser';
import zlib from 'node:zlib';
import fs from 'node:fs/promises';
import path from 'node:path';
import { setTimeout as delay } from 'node:timers/promises';
import { createClient } from '@supabase/supabase-js';

const SEARCH_URL = process.env.MX_SEARCH_URL || 'https://iptv-org.github.io/?q=live%20country:MX';
const EPG_GZ_URL = process.env.MX_EPG_URL || 'https://epgshare01.online/epgshare01/epg_ripper_MX1.xml.gz';

const HEADLESS = (process.env.HEADLESS ?? 'true') !== 'false';
const MAX_CHANNELS = Number(process.env.MAX_CHANNELS || '0'); // 0 = no cap
const PER_PAGE_DELAY_MS = Number(process.env.PER_PAGE_DELAY_MS || '150');
const NAV_TIMEOUT_MS = Number(process.env.NAV_TIMEOUT_MS || '30000');
const PROBE_TIMEOUT_MS = Number(process.env.PROBE_TIMEOUT_MS || '5000');

const SUPABASE_URL = process.env.SUPABASE_URL || '';
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY || '';
const SUPABASE_TABLE = process.env.SUPABASE_TABLE || 'epg_streams';

// ---------- NORMALIZATION / MATCHING ----------
function stripAccents(s) {
  return s.normalize('NFD').replace(/\p{Diacritic}+/gu, '');
}
const STOP = new Set(['canal', 'tv', 'television', 'hd', 'sd', 'mx', 'mexico', 'mÃ©xico']);
function tokensOf(s) {
  if (!s) return [];
  const plain = stripAccents(String(s).toLowerCase());
  const cleaned = plain.replace(/&/g, ' and ').replace(/[^a-z0-9]+/g, ' ').trim();
  return cleaned.split(/\s+/).filter(t => t && !STOP.has(t));
}
function keyOf(s) {
  const t = Array.from(new Set(tokensOf(s))).sort();
  return t.join(' ');
}

function uniqBy(arr, keyFn) {
  const m = new Map();
  for (const x of arr) {
    const k = keyFn(x);
    if (!m.has(k)) m.set(k, x);
  }
  return [...m.values()];
}

async function fetchBuf(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`Fetch failed ${r.status} ${url}`);
  return Buffer.from(await r.arrayBuffer());
}

// ---------- SCRAPE CHANNEL LIST PAGE ----------
async function collectChannelPages(browser) {
  const page = await browser.newPage();
  page.setDefaultTimeout(NAV_TIMEOUT_MS);
  await page.goto(SEARCH_URL, { waitUntil: 'domcontentloaded' });
  // Wait for channel anchors to show (client-side filter)
  await page.waitForSelector('a[href*="/channels/"]', { timeout: 15000 }).catch(() => {});
  await page.waitForTimeout(1000);

  let items = await page.$$eval('a[href*="/channels/"]', (as) => {
    const out = [];
    for (const a of as) {
      const href = a.getAttribute('href') || '';
      if (!href.includes('/channels/')) continue;
      const url = new URL(href, location.href).href;
      const name = (a.textContent || '').trim();
      // find closest image as logo
      let logo = null;
      const row = a.closest('tr,li,article,div') || a.parentElement;
      if (row) {
        const img = row.querySelector('img');
        if (img) logo = img.src || img.getAttribute('src');
      }
      out.push({ url, name, logo });
    }
    const m = new Map();
    for (const it of out) if (!m.has(it.url)) m.set(it.url, it);
    return [...m.values()];
  });

  items = items.filter(i => i.name && i.url);
  items = uniqBy(items, x => x.url);

  if (MAX_CHANNELS > 0 && items.length > MAX_CHANNELS) items = items.slice(0, MAX_CHANNELS);
  await page.close();
  return items.map(i => ({ ...i, nameKey: keyOf(i.name) }));
}

// ---------- SCRAPE PER-CHANNEL PAGE FOR .m3u8 ----------
async function scrapeChannel(browser, link) {
  const page = await browser.newPage();
  page.setDefaultTimeout(NAV_TIMEOUT_MS);
  try {
    await page.goto(link.url, { waitUntil: 'domcontentloaded' });
    await page.waitForTimeout(500);

    // Try to click "Streams" tab/section if present
    const tab = await

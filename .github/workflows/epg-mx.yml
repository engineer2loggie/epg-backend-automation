name: EPG-MX

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 7 * * *' # daily 07:00 UTC

concurrency:
  group: epg-mx
  cancel-in-progress: true

jobs:
  mx:
    runs-on: ubuntu-latest
    timeout-minutes: 300

    env:
      MX_SEARCH_URL: https://iptv-org.github.io/?q=live%20country:MX
      MX_EPG_URLS: >-
        https://epgshare01.online/epgshare01/epg_ripper_US1.xml.gz
        https://epgshare01.online/epgshare01/epg_ripper_US_LOCALS2.xml.gz
        https://epgshare01.online/epgshare01/epg_ripper_MX1.xml.gz
      M3U_URL: ${{ secrets.M3U_URL }}     # optional
      MAPPING_URL: ${{ secrets.MAPPING_URL }} # optional manual mapping JSON
      HEADLESS: 'true'
      MAX_CHANNELS: '0'
      PER_PAGE_DELAY_MS: '150'
      NAV_TIMEOUT_MS: '30000'
      PROBE_TIMEOUT_MS: '5000'
      FUZZY_MIN: '0.45'
      LOG_UNMATCHED: '1'
      INGEST_PROGRAMS: '1'
      PROGRAMS_HOURS_AHEAD: '36'
      SUPABASE_SCHEMA: public
      SUPABASE_TABLE: mx_channels
      PROGRAMS_TABLE: epg_programs
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
      NORDVPN_TOKEN: ${{ secrets.NORDVPN_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Node deps (Playwright, Supabase, Saxes)
        shell: bash
        run: |
          set -euo pipefail
          npm i --no-save playwright saxes @supabase/supabase-js
          npx playwright install --with-deps chromium

      - name: Install NordVPN CLI
        if: ${{ env.NORDVPN_TOKEN != '' }}
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y curl gnupg expect
          curl -sSf https://repo.nordvpn.com/gpg/nordvpn_public.asc \
            | sudo gpg --dearmor -o /usr/share/keyrings/nordvpn-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/nordvpn-archive-keyring.gpg] https://repo.nordvpn.com/deb/nordvpn/debian stable main" \
            | sudo tee /etc/apt/sources.list.d/nordvpn.list
          sudo apt-get update
          sudo apt-get install -y nordvpn
          sudo systemctl enable --now nordvpnd || true

      - name: Make non-interactive nordvpn wrapper
        if: ${{ env.NORDVPN_TOKEN != '' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts
          cat > scripts/nordvpn.exp <<'EXP'
          #!/usr/bin/expect -f
          set timeout 180
          if {$argc < 1} { exit 2 }
          log_user 1
          spawn -noecho sudo nordvpn {*}$argv
          expect {
            -re "(?i)\\(y/n\\)\\s*$"            { send -- "n\r"; exp_continue }
            -re "(?i)yes/no\\)?\\s*$"           { send -- "no\r"; exp_continue }
            -re "(?i)Would you like.*\\(y/n\\)" { send -- "n\r"; exp_continue }
            -re "(?i)Do you allow.*\\(y/n\\)"   { send -- "n\r"; exp_continue }
            -re "(?i)Status:\\s*Connected"      { }
            -re "(?i)Connected"                 { }
            timeout                             { exit 124 }
            eof                                 { }
          }
          catch wait result
          if {[lindex $result 3] == 0} { exit 0 } else { exit [lindex $result 3] }
          EXP
          chmod +x scripts/nordvpn.exp

      - name: Connect VPN (Mexico)
        if: ${{ env.NORDVPN_TOKEN != '' }}
        shell: bash
        run: |
          set -euo pipefail
          scripts/nordvpn.exp login --token "$NORDVPN_TOKEN" || true
          scripts/nordvpn.exp set analytics disabled || true
          scripts/nordvpn.exp set technology nordlynx || true
          scripts/nordvpn.exp set firewall off || true
          scripts/nordvpn.exp set killswitch off || true

          attempts=5
          connected=0
          for i in $(seq 1 $attempts); do
            echo "Attempt $i/$attempts: connecting to Mexico..."
            if timeout -k 10s 75s scripts/nordvpn.exp connect Mexico; then
              sleep 2
            fi
            if sudo nordvpn status | grep -qi 'Status: Connected'; then
              echo "VPN Connected."
              connected=1; break
            fi
            echo "Retrying..."
            sudo nordvpn disconnect || true
            sleep 6
          done

          if [ "$connected" -ne 1 ]; then
            echo "Failed to connect to NordVPN Mexico."
            sudo nordvpn status || true
            exit 1
          fi

          echo "::group::Egress Check"
          curl -s https://ifconfig.io ; echo
          echo -n "Country: "; curl -s https://ifconfig.io/country || true
          echo "::endgroup::"

      - name: Write scraper script
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts out/mx
          cat > scripts/mx-scrape-and-match.mjs <<'EOF'
          // Scrape MX channels (iptv-org), probe streams, parse EPG (multi .xml.gz),
          // prefer matches by M3U tvg-id, fallback to normalized-name; upsert streams/programs.

          import { chromium } from 'playwright';
          import { createGunzip } from 'node:zlib';
          import { Readable } from 'node:stream';
          import fs from 'node:fs/promises';
          import path from 'node:path';
          import { setTimeout as delay } from 'node:timers/promises';
          import { createClient } from '@supabase/supabase-js';
          import { SaxesParser } from 'saxes';

          // ---------- ENV ----------
          const SEARCH_URL = process.env.MX_SEARCH_URL || 'https://iptv-org.github.io/?q=live%20country:MX';
          const EPG_URLS = (process.env.MX_EPG_URLS || '').trim().split(/\s+/).filter(Boolean);
          const M3U_URL = (process.env.M3U_URL || '').trim();
          const MAPPING_URL = (process.env.MAPPING_URL || '').trim(); // optional override JSON

          const HEADLESS = (process.env.HEADLESS ?? 'true') !== 'false';
          const MAX_CHANNELS = Number(process.env.MAX_CHANNELS || '0');
          const PER_PAGE_DELAY_MS = Number(process.env.PER_PAGE_DELAY_MS || '150');
          const NAV_TIMEOUT_MS = Number(process.env.NAV_TIMEOUT_MS || '30000');
          const PROBE_TIMEOUT_MS = Number(process.env.PROBE_TIMEOUT_MS || '5000');
          const FUZZY_MIN = Number(process.env.FUZZY_MIN || '0.45');
          const LOG_UNMATCHED = process.env.LOG_UNMATCHED === '1';
          const INGEST_PROGRAMS = (process.env.INGEST_PROGRAMS || '0') === '1';
          const PROGRAMS_HOURS_AHEAD = Number(process.env.PROGRAMS_HOURS_AHEAD || '36');

          const SUPABASE_URL = process.env.SUPABASE_URL || '';
          const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY || '';
          const SUPABASE_SCHEMA = process.env.SUPABASE_SCHEMA || 'public';
          const SUPABASE_TABLE = process.env.SUPABASE_TABLE || 'mx_channels';
          const PROGRAMS_TABLE = process.env.PROGRAMS_TABLE || 'epg_programs';

          const EPG_RETRIES = 3;
          const EPG_RETRY_DELAY_MS = 2000;

          // ---------- NORMALIZATION ----------
          function stripAccents(s){return String(s).normalize('NFD').replace(/\p{Diacritic}+/gu,'');}
          function normalizeNumerals(s){const map={uno:'1',dos:'2',tres:'3',cuatro:'4',cinco:'5',seis:'6',siete:'7',ocho:'8',nueve:'9',diez:'10',once:'11',doce:'12',trece:'13'};return String(s).replace(/\b(uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez|once|doce|trece)\b/gi,m=>map[m.toLowerCase()]);}
          function dropTimeshift(s){return String(s).replace(/(?:[-+]\s*\d+\s*(?:h|hora|horas)\b)/ig,'').replace(/\b\d+\s*horas?\b/ig,'').replace(/\(\s*\d+\s*horas?\s*\)/ig,'').replace(/\btime\s*shift\b/ig,'').replace(/\s{2,}/g,' ').trim();}
          function stripLeadingCanal(s){return String(s).replace(/^\s*canal[\s._-]+/i,'');}
          function stripCountryTail(s){return String(s).replace(/(\.(mx|us)|\s+\(?mx\)?|\s+m[eé]xico|\s+usa|\s+eeuu)\s*$/i,'').trim();}
          const STOP=new Set(['canal','tv','television','hd','sd','mx','mexico','méxico','hora','horas','us','usa','eeuu']);
          function tokensOf(s){if(!s)return[];let p=stripAccents(normalizeNumerals(String(s).toLowerCase()));p=dropTimeshift(p);p=stripCountryTail(p);p=p.replace(/&/g,' and ').replace(/[^a-z0-9]+/g,' ').trim();return p.split(/\s+/).filter(t=>t&&!STOP.has(t));}
          function keyOf(s){return Array.from(new Set(tokensOf(s))).sort().join(' ');}
          function expandNameVariants(s){if(!s)return[];const out=new Set();const orig=String(s).trim();const noCanal=stripLeadingCanal(orig);const flat=x=>x.replace(/[._(),]+/g,' ').replace(/\s+/g,' ').trim();const noTS=dropTimeshift(noCanal);const noTail=stripCountryTail(noTS);[orig,noCanal,noTS,noTail,flat(orig),flat(noCanal),flat(noTS),flat(noTail)].forEach(v=>{if(v)out.add(v);});return[...out];}
          function containsMexicoTag(s){const t=stripAccents(String(s).toLowerCase()).replace(/[^a-z0-9]+/g,' ').trim();const parts=t.split(/\s+/);return parts.includes('mexico')||parts.includes('mx')||/\.mx\b/i.test(String(s));}
          function uniqBy(arr,keyFn){const m=new Map();for(const x of arr){const k=keyFn(x);if(!m.has(k))m.set(k,x);}return[...m.values()];}

          // ---------- UTILS ----------
          async function retryFetch(url, options = {}, retries = EPG_RETRIES, delayMs = EPG_RETRY_DELAY_MS) {
            for (let i=0;i<retries;i++){
              try{ const r=await fetch(url,options); if(!r.ok) throw new Error(`HTTP ${r.status}`); return r; }
              catch(e){ if(i===retries-1) throw e; await delay(delayMs); }
            }
          }
          async function promiseAllWithConcurrency(conc, items, fn){
            const out=[]; let idx=0;
            const workers=Array(Math.max(1,conc)).fill(0).map(async()=>{ while(idx<items.length){ const i=idx++; out[i]=await fn(items[i],i); }});
            await Promise.all(workers); return out;
          }
          function parseXmltvToISO(s){
            const m=String(s).match(/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(?:\s*([+-]\d{4}|Z))?$/);
            if(!m) return null;
            const [,Y,Mo,D,h,mi,se,off]=m;
            const base=Date.UTC(+Y,+Mo-1,+D,+h,+mi,+se);
            if(!off||off==='Z') return new Date(base).toISOString();
            const sign=off.startsWith('-')?-1:1; const hh=+off.slice(1,3), mm=+off.slice(3,5);
            return new Date(base - sign*(hh*60+mm)*60*1000).toISOString();
          }

          // ---------- M3U + mapping ----------
          function parseM3U(text){
            const items=[]; let cur=null;
            for(const raw of text.split(/\r?\n/)){
              const line=raw.trim(); if(!line) continue;
              if(line.startsWith('#EXTINF')){
                const attrs={}; for(const m of line.matchAll(/\b([a-z0-9_-]+)="([^"]*)"/gi)){ attrs[m[1].toLowerCase()]=m[2]; }
                const comma=line.indexOf(','); const title=comma>=0?line.slice(comma+1).trim():'';
                cur={tvg_id:attrs['tvg-id']||null, tvg_name:attrs['tvg-name']||title||null, url:null};
              }else if(!line.startsWith('#')&&cur){cur.url=line; items.push(cur); cur=null;}
            }
            return items;
          }
          async function buildM3UMaps(){
            const maps={ byUrl:new Map(), byName:new Map() };
            if(!M3U_URL) return maps;
            try{
              const txt=await (await retryFetch(M3U_URL,{headers:{'user-agent':'curl/8'}})).text();
              const items=parseM3U(txt);
              for(const it of items) if(it.url&&it.tvg_id) maps.byUrl.set(it.url,it.tvg_id);
              for(const it of items){ const k=keyOf(it.tvg_name||''); if(k && it.tvg_id && !maps.byName.has(k)) maps.byName.set(k,it.tvg_id); }
              console.log(`M3U parsed: ${items.length} lines -> ${maps.byUrl.size} url->tvg_id, ${maps.byName.size} name->tvg_id`);
            }catch(e){ console.warn(`M3U fetch/parse failed: ${e.message}`); }
            return maps;
          }
          async function loadManualMapping(){
            // format: [{"epg_id":"...", "m3u_name":"...", "m3u_tvg-id":"...", "custom_channel_name":"..."}]
            const map = new Map();
            if(!MAPPING_URL) return map;
            try{
              const txt=await (await retryFetch(MAPPING_URL)).text();
              const arr=JSON.parse(txt);
              for(const r of arr||[]){ if(r && r.epg_id && (r['m3u_tvg-id'] || r.m3u_name)){ map.set((r['m3u_tvg-id']||keyOf(r.m3u_name)), r.epg_id); } }
              console.log(`Manual mapping loaded: ${map.size} entries`);
            }catch(e){ console.warn(`Manual mapping skipped: ${e.message}`); }
            return map;
          }

          // ---------- SCRAPING ----------
          async function collectChannelPages(browser){
            const page=await browser.newPage(); page.setDefaultTimeout(NAV_TIMEOUT_MS);
            await page.goto(SEARCH_URL,{waitUntil:'domcontentloaded'});
            await page.waitForSelector('a[href*="/channels/"]',{timeout:15000}).catch(()=>{});
            await page.waitForTimeout(800);
            let items=await page.$$eval('a[href*="/channels/"]',as=>{
              const out=[]; for(const a of as){ const href=a.getAttribute('href')||''; if(!href.includes('/channels/'))continue;
                out.push({url:new URL(href,location.href).href, name:(a.textContent||'').trim()}); }
              const m=new Map(); for(const it of out) if(!m.has(it.url)) m.set(it.url,it); return [...m.values()];
            });
            items=items.filter(i=>i.name&&i.url);
            items=uniqBy(items,x=>x.url);
            if(MAX_CHANNELS>0 && items.length>MAX_CHANNELS) items=items.slice(0,MAX_CHANNELS);
            await page.close();
            return items.map(i=>({...i, nameKey:keyOf(i.name)}));
          }
          async function scrapeChannel(browser,link){
            const page=await browser.newPage(); page.setDefaultTimeout(NAV_TIMEOUT_MS);
            try{
              await page.goto(link.url,{waitUntil:'domcontentloaded'}); await page.waitForTimeout(400);
              const tab=await page.$('text=Streams'); if(tab){ await tab.click().catch(()=>{}); await page.waitForTimeout(300); }
              let anchors=await page.$$eval('a[href*=".m3u8"]',els=>els.map(e=>({url:e.href,text:(e.textContent||'').trim()})));
              if(!anchors.length){
                const html=await page.content(); const rx=/https?:\/\/[^\s"'<>]+\.m3u8[^\s"'<>]*/gi;
                const set=new Set(); let m; while((m=rx.exec(html))) set.add(m[0]); anchors=[...set].map(u=>({url:u,text:''}));
              }
              anchors=uniqBy(anchors.filter(a=>/^https?:\/\//i.test(a.url)),a=>a.url);
              return anchors.map(a=>({url:a.url, quality:(a.text.match(/\b(1080p|720p|480p|360p|HD|SD)\b/i)||[])[0]||null}));
            }catch(e){ console.error(`Error scraping ${link.url}: ${e.message}`); return []; }
            finally{ await page.close(); }
          }
          async function scrapeAll(browser,links){
            const conc=10;
            const res=await promiseAllWithConcurrency(conc,links, async l=>{
              const streams=await scrapeChannel(browser,l);
              await delay(PER_PAGE_DELAY_MS);
              return { channelName:l.name, channelNameKey:l.nameKey, streams };
            });
            return res.filter(r=>r.streams.length>0);
          }
          async function probeM3U8(url){
            const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),PROBE_TIMEOUT_MS);
            try{
              const r=await fetch(url,{method:'GET',headers:{'user-agent':'Mozilla/5.0','accept':'application/vnd.apple.mpegurl,text/plain,*/*'},signal:ac.signal});
              if(!r.ok) return false; const txt=await r.text(); return txt.includes('#EXTM3U');
            }catch{ return false; } finally{ clearTimeout(t); }
          }

          // ---------- EPG PARSING ----------
          function isMexicoEntry(id,names){
            const s=String(id||'');
            const idLooks=/\bmx\b/i.test(s)||/\.mx\b/i.test(s)||/\bm[ée]xico\b/i.test(s);
            const nameLooks=(names||[]).some(n=>/\b(m[ée]xico|mx)\b/i.test(String(n)));
            return idLooks||nameLooks;
          }

          async function saveProgramsBatch(batch){
            if(!batch.length || !INGEST_PROGRAMS) return;
            if(!SUPABASE_URL||!SUPABASE_SERVICE_KEY) return;
            const sb=createClient(SUPABASE_URL,SUPABASE_SERVICE_KEY,{auth:{persistSession:false},db:{schema:SUPABASE_SCHEMA}});
            const { error } = await sb.from(PROGRAMS_TABLE).upsert(batch, { onConflict: 'channel_id,start_ts' });
            if(error) console.warn(`Programs upsert failed: ${error.message}`);
          }

          async function parseOneEpg(url, agg, keepAllMexFile){
            console.log(`Downloading EPG (stream)… ${url}`);
            const res=await retryFetch(url); if(!res.ok||!res.body) throw new Error(`Fetch failed ${res.status}`);
            const gunzip=createGunzip(); const src=Readable.fromWeb(res.body);
            const decoder=new TextDecoder('utf-8'); const parser=new SaxesParser({xmlns:false});

            const MAX_NAME_CHARS=1024, MAX_NAMES_PER_CH=24, MAX_VARIANTS=64;
            let cur=null,inDisp=false,dispChunks=[],dispLen=0,dispTruncated=false;
            const tagStack=[];

            parser.on('error',(e)=>{ throw e; });
            parser.on('opentag',(tag)=>{
              const nm=String(tag.name).toLowerCase(); tagStack.push(nm);
              if(nm==='channel'){ cur={id:tag.attributes?.id?String(tag.attributes.id):'', namesRaw:[]}; }
              else if(nm==='display-name'&&cur){ inDisp=true; dispChunks=[]; dispLen=0; dispTruncated=false; }
              else if(nm==='programme'){ const cid=String(tag.attributes?.channel||''); agg.programmeOpen = cid ? { channel:cid, attrs:tag.attributes, text:{} } : null; }
            });
            parser.on('text',(t)=>{
              const raw=String(t); if(!raw) return;
              if(inDisp&&cur&&!dispTruncated){
                let chunk=raw; if(chunk.length>MAX_NAME_CHARS) chunk=chunk.slice(0,MAX_NAME_CHARS);
                const remain=MAX_NAME_CHARS-dispLen; if(remain<=0){dispTruncated=true;return;}
                if(chunk.length>remain){chunk=chunk.slice(0,remain);dispTruncated=true;}
                if(chunk){dispChunks.push(chunk);dispLen+=chunk.length;}
                return;
              }
              if(!agg.programmeOpen) return;
              const curTag=tagStack[tagStack.length-1] || '';
              if(!curTag || curTag==='programme') return;
              const str=raw.trim(); if(!str) return;
              if(!agg.programmeOpen.text[curTag]) agg.programmeOpen.text[curTag]=[];
              agg.programmeOpen.text[curTag].push(str);
            });
            parser.on('closetag', async (nameRaw)=>{
              const nm=String(nameRaw).toLowerCase();
              if(nm==='display-name'&&cur){
                if(cur.namesRaw.length<MAX_NAMES_PER_CH){ const txt=dispChunks.length?dispChunks.join(''):''; const clean=txt.trim(); if(clean) cur.namesRaw.push(clean); }
                inDisp=false; dispChunks=[]; dispLen=0; dispTruncated=false;
              }else if(nm==='channel'&&cur){
                const id=cur.id||''; const keep = keepAllMexFile ? true : isMexicoEntry(id,cur.namesRaw);
                if(keep){
                  const names=new Set(); for(const n of cur.namesRaw) for(const v of expandNameVariants(n)) if(v) names.add(v);
                  for(const v of expandNameVariants(id)) if(v) names.add(v);
                  const limited=[]; for(const v of names){ limited.push(v); if(limited.length>=MAX_VARIANTS) break; }
                  let entry=agg.channels.get(id); if(!entry) { entry={id, names:[], tokenSet:new Set()}; agg.channels.set(id,entry); }
                  entry.names=Array.from(new Set(entry.names.concat(limited))).slice(0,MAX_VARIANTS);
                  entry.tokenSet=new Set(); for(const nm2 of entry.names) for(const tok of tokensOf(nm2)) entry.tokenSet.add(tok);
                  for(const n of entry.names){ const k=keyOf(n); if(k && !agg.nameMap.has(k)) agg.nameMap.set(k,entry); }
                }
                cur=null; inDisp=false; dispChunks=[]; dispLen=0; dispTruncated=false;
              }else if(nm==='programme'&&agg.programmeOpen){
                if(INGEST_PROGRAMS){
                  const cid=agg.programmeOpen.channel;
                  const entry=agg.channels.get(cid);
                  const keep = keepAllMexFile ? true : (entry ? isMexicoEntry(entry.id,entry.names) : containsMexicoTag(cid));
                  if(keep){
                    const a=agg.programmeOpen.attrs||{}, t=agg.programmeOpen.text||{};
                    const startISO=parseXmltvToISO(a.start||''); const stopISO=parseXmltvToISO(a.stop||'');
                    if(startISO&&stopISO){
                      const now=Date.now(), ahead=now+PROGRAMS_HOURS_AHEAD*3600*1000;
                      const st=Date.parse(startISO), en=Date.parse(stopISO);
                      if(Number.isFinite(st)&&Number.isFinite(en)&&!(en<now-6*3600*1000||st>ahead)){
                        const textOf=k=>(t[k]?.join(' ')||null); const arrOf=k=>(t[k]?Array.from(new Set(t[k])):null);
                        const rec={
                          channel_id:cid, title:textOf('title'), sub_title:textOf('sub-title'), summary:textOf('desc'),
                          start_ts:startISO, stop_ts:stopISO, categories:arrOf('category'),
                          icon_url:null, rating:t['rating']?{text:t['rating'].join(' ')}:null, star_rating:textOf('star-rating'),
                          program_url:textOf('url'), episode_num_xmltv:textOf('episode-num'),
                          season:null, episode:null, language:textOf('language'), orig_language:textOf('orig-language'),
                          credits:null, premiere:!!t['premiere'], previously_shown:!!t['previously-shown'], extras:null,
                          ingested_at:new Date().toISOString()
                        };
                        if(t['episode-num']){ const ns=t['episode-num'].find(x=>/xmltv_ns/.test(x)); const m=ns&&ns.match(/(\d+)\.(\d+)(?:\.(\d+))?/); if(m){ rec.season=Number(m[1])+1; rec.episode=Number(m[2])+1; } }
                        const creditKeys=['actor','director','writer','adapter','producer','composer','editor','presenter','commentator','guest'];
                        const credits={}; for(const k of creditKeys) if(t[k]) credits[k]=Array.from(new Set(t[k])); rec.credits=Object.keys(credits).length?credits:null;
                        agg.programmeBatch.push(rec);
                        if(agg.programmeBatch.length>=500){ await saveProgramsBatch(agg.programmeBatch); agg.programmeBatch=[]; }
                      }
                    }
                  }
                }
                agg.programmeOpen=null;
              }
              // pop stack
              if(tagStack.length && tagStack[tagStack.length-1]===nm) tagStack.pop();
              else { const idx=tagStack.lastIndexOf(nm); if(idx>=0) tagStack.splice(idx,1); }
            });

            await new Promise((resolve,reject)=>{
              src.on('error',reject);
              gunzip.on('error',reject);
              gunzip.on('data',(chunk)=>{ const text=decoder.decode(chunk,{stream:true}); if(text) parser.write(text); });
              gunzip.on('end', async ()=>{ parser.write(decoder.decode(new Uint8Array(),{stream:false})); parser.close();
                if(INGEST_PROGRAMS && agg.programmeBatch.length){ await saveProgramsBatch(agg.programmeBatch); agg.programmeBatch=[]; }
                resolve(); });
              src.pipe(gunzip);
            });
          }

          async function parseAllEpg(urls){
            const agg={ channels:new Map(), nameMap:new Map(), programmeOpen:null, programmeBatch:[] };
            let ok=0;
            for(const url of urls){ try{ const keepAll=/_MX/i.test(url); await parseOneEpg(url,agg,keepAll); ok++; }catch(e){ console.warn(`EPG parse failed ${url}: ${e.message}`); } }
            const entries=[...agg.channels.values()];
            console.log(`EPG files parsed OK: ${ok}/${urls.length}`);
            console.log(`EPG channels kept (after filtering): ${entries.length}`);
            try{
              await fs.writeFile('out/mx/epg_channels_sample.json', JSON.stringify(entries.slice(0,50),null,2), 'utf8');
              await fs.writeFile('out/mx/epg_entries_count.txt', `entries: ${entries.length}\n`, 'utf8');
            }catch{}
            return { nameMap: agg.nameMap, entries };
          }

          // ---------- MATCH ----------
          function jaccard(aTokens,bTokens){const A=new Set(aTokens),B=new Set(bTokens);let inter=0;for(const t of A) if(B.has(t)) inter++; return inter/(A.size+B.size-inter||1);}
          function findMatchByName(channelName, nameKey, nameMap, entries){
            const exact=nameMap.get(nameKey); if(exact) return {entry:exact,score:1,method:'exact'};
            const sTokArr=tokensOf(channelName); const sTok=new Set(sTokArr);
            if(sTok.size===1){ const [only]=[...sTok]; for(const e of entries) if(e.tokenSet && e.tokenSet.has(only)) return {entry:e,score:0.99,method:'anchor'}; }
            let subsetBest=null, subsetSize=Infinity;
            for(const e of entries){ const E=e.tokenSet||new Set(); let all=true; for(const t of sTok){ if(!E.has(t)){all=false;break;} } if(all && E.size<subsetSize){ subsetBest=e; subsetSize=E.size; } }
            if(subsetBest) return {entry:subsetBest,score:0.9,method:'subset'};
            let best=null,bestScore=0; for(const e of entries) for(const nm of e.names){ const sc=jaccard(sTokArr,tokensOf(nm)); if(sc>bestScore){bestScore=sc; best=e;} }
            if(best && bestScore>=FUZZY_MIN) return {entry:best,score:bestScore,method:'fuzzy'};
            return {entry:null,score:0,method:'none'};
          }

          // ---------- DB ----------
          function sbClient(){ return createClient(SUPABASE_URL,SUPABASE_SERVICE_KEY,{auth:{persistSession:false},db:{schema:SUPABASE_SCHEMA}}); }

          async function saveStreams(rows){
            if(!SUPABASE_URL||!SUPABASE_SERVICE_KEY){ console.log('Supabase env missing; skipped DB upload.'); return;}
            if(!rows.length){ console.log('No stream rows to upload.'); return;}
            const sb=sbClient();

            // Try with tvg_id + channel_name; then fallbacks
            const attempts=[
              r=>({stream_url:r.stream_url, channel_guess:r.channel_guess, channel_name:r.channel_name, tvg_id:r.tvg_id, epg_channel_id:r.epg_channel_id, epg_display_name:r.epg_display_name, working:r.working, checked_at:r.checked_at}),
              r=>({stream_url:r.stream_url, channel_guess:r.channel_guess, tvg_id:r.tvg_id, epg_channel_id:r.epg_channel_id, epg_display_name:r.epg_display_name, working:r.working, checked_at:r.checked_at}),
              r=>({stream_url:r.stream_url, channel_guess:r.channel_guess, epg_channel_id:r.epg_channel_id, epg_display_name:r.epg_display_name, working:r.working, checked_at:r.checked_at})
            ];
            let lastErr=null;
            for(const build of attempts){
              const payload=rows.map(build);
              const { error } = await sb.from(SUPABASE_TABLE).upsert(payload, { onConflict: 'stream_url', ignoreDuplicates:false });
              if(!error){ console.log(`Streams DB write OK: ${rows.length} rows`); return; }
              lastErr=error; console.warn(`Streams upsert attempt failed: ${error.message}`);
            }
            if(lastErr) console.warn(`Streams upsert gave up: ${lastErr.message}`);
          }

          // ---------- MAIN ----------
          async function ensureDir(p){ await fs.mkdir(p,{recursive:true}); }

          async function main(){
            if(!EPG_URLS.length) throw new Error('No EPG URLs provided');
            await ensureDir('out/mx');
            const browser=await chromium.launch({headless:HEADLESS});
            const m3uMaps=await buildM3UMaps();
            const manualMap=await loadManualMapping();

            try{
              console.log(`Scraping: ${SEARCH_URL}`);
              const links=await collectChannelPages(browser);
              console.log(`Found ${links.length} channel pages.`);

              const scraped=await scrapeAll(browser,links);
              console.log(`Channels with at least one .m3u8 (before probe): ${scraped.length}`);

              const allUrls=[...new Set(scraped.flatMap(ch=>ch.streams.map(s=>s.url)))];
              console.log(`Probing ${allUrls.length} unique streams in parallel...`);
              const results=await promiseAllWithConcurrency(50, allUrls, async u=>({u, ok:await probeM3U8(u)}));
              const working=new Set(results.filter(r=>r.ok).map(r=>r.u));
              console.log(`Found ${working.size} working streams.`);

              const filtered = scraped.map(ch=>({...ch, streams: ch.streams.filter(s=>working.has(s.url))}))
                                      .filter(ch=>ch.streams.length>0);
              console.log(`Channels with at least one WORKING .m3u8: ${filtered.length}`);

              const { nameMap, entries } = await parseAllEpg(EPG_URLS);

              const records=[], matchedOnly=[];
              for(const r of filtered){
                const nameTvg = m3uMaps.byName.get(r.channelNameKey) || null;
                let bestEntry=null, method='none';

                // If manual mapping matches (by tvg-id or normalized name), take it
                const manualKey = nameTvg || r.channelNameKey;
                const manualEpgId = manualMap.get(manualKey) || null;
                if(manualEpgId){
                  bestEntry = entries.find(e=>e.id===manualEpgId) || null;
                  method = bestEntry ? 'manual-map' : 'manual-map-miss';
                }

                if(!bestEntry){
                  const m=findMatchByName(r.channelName, r.channelNameKey, nameMap, entries);
                  bestEntry=m.entry; method=m.method;
                }

                for(const s of r.streams){
                  const urlTvg = m3uMaps.byUrl.get(s.url) || null;
                  const tvg_id = urlTvg || nameTvg || (bestEntry ? bestEntry.id : null);
                  const rec={
                    stream_url:s.url,
                    channel_guess:r.channelName,
                    channel_name: bestEntry ? (bestEntry.names[0]||r.channelName) : r.channelName,
                    tvg_id,
                    epg_channel_id: bestEntry ? bestEntry.id : tvg_id,
                    epg_display_name: bestEntry ? (bestEntry.names[0] || null) : null,
                    working:true,
                    checked_at:new Date().toISOString()
                  };
                  records.push(rec);
                  if(bestEntry) matchedOnly.push({...rec, _match_method:method});
                }
              }

              console.log(`Matched with EPG: ${matchedOnly.length} stream rows (across ${filtered.length} channels).`);

              await fs.writeFile(path.join('out','mx','records.json'), JSON.stringify(records,null,2), 'utf8');
              await fs.writeFile(path.join('out','mx','matches.json'), JSON.stringify(matchedOnly,null,2), 'utf8');
              if(LOG_UNMATCHED){
                const matchedUrls=new Set(matchedOnly.map(x=>x.stream_url));
                const unmatched=records.filter(x=>!matchedUrls.has(x.stream_url));
                await fs.writeFile(path.join('out','mx','unmatched.json'), JSON.stringify(unmatched,null,2), 'utf8');
                console.log(`Wrote out/mx/unmatched.json with ${unmatched.length} unmatched rows`);
              }

              await saveStreams(records);

              if(!INGEST_PROGRAMS){
                await fs.writeFile(path.join('out','mx','epg_programs_sample.json'),
                  JSON.stringify({note:'program ingestion disabled'},null,2),'utf8');
              }
            } finally { await browser.close(); }
          }

          main().catch(e=>{ console.error(e); process.exit(1); });
          EOF

      - name: Run MX scrape & match
        shell: bash
        run: |
          set -euo pipefail
          node scripts/mx-scrape-and-match.mjs

      - name: NordVPN disconnect
        if: ${{ always() && env.NORDVPN_TOKEN != '' }}
        shell: bash
        run: |
          set -euo pipefail
          sudo nordvpn disconnect || true
          sudo nordvpn status || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mx-output
          path: |
            out/mx/records.json
            out/mx/matches.json
            out/mx/unmatched.json
            out/mx/epg_channels_sample.json
            out/mx/epg_entries_count.txt
            out/mx/epg_programs_sample.json
          if-no-files-found: warn

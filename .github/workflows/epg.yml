name: Build EPG (selected countries)

on:
  workflow_dispatch:
  schedule:
    - cron: "22 2 * * *"  # daily

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cc: [US, PR, MX, CA, IT, ES, GB, AU, IE, DE, DO] # UK=GB
    env:
      NODE_OPTIONS: --max-old-space-size=2048
      BLOCKED_SITES: directv.com,mi.tv,tvtv.us,tvpassport.com,gatotv.com
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Clone iptv-org/epg (site configs & grabber scripts)
        run: |
          git clone --depth=1 https://github.com/iptv-org/epg.git epg-src
          cd epg-src
          npm ci

      - name: Fetch iptv-org datasets
        run: |
          curl -sL https://iptv-org.github.io/api/channels.json -o channels.json
          curl -sL https://iptv-org.github.io/api/guides.json   -o guides.json

      - name: Build per-site channels for ${{ matrix.cc }}
        env:
          CC: ${{ matrix.cc }}
          BLOCKED: ${{ env.BLOCKED_SITES }}
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const CC = process.env.CC;
          const BLOCKED = new Set((process.env.BLOCKED||'').split(',').map(s=>s.trim()).filter(Boolean));

          const channels = JSON.parse(fs.readFileSync('channels.json','utf8'));
          const guides   = JSON.parse(fs.readFileSync('guides.json','utf8'));

          // filter channels by country
          const chanById = new Map(
            channels
              .filter(c => c && c.id && String(c.country||'').toUpperCase() === CC)
              .map(c => [c.id, c])
          );

          // group guides by site, but only those that match our channels and arenâ€™t blocked
          const bySite = new Map();
          for (const g of guides) {
            if (!g || !g.channel || !g.site || !g.site_id) continue;
            if (!chanById.has(g.channel)) continue;
            if (BLOCKED.has(g.site)) continue;
            if (!bySite.has(g.site)) bySite.set(g.site, []);
            bySite.get(g.site).push(g);
          }

          // only keep sites for which a config exists in epg-src/sites/<site>/<site>.config.js
          const existingSites = [];
          for (const [site, list] of bySite) {
            const cfgPath = path.join('epg-src','sites',site,`${site}.config.js`);
            if (fs.existsSync(cfgPath)) {
              existingSites.push(site);
            } else {
              console.log(`Skipping site without config: ${site} (has ${list.length} rows)`);
              bySite.delete(site);
            }
          }

          if (!existingSites.length) {
            console.log(`No usable sites for ${CC}`);
            process.exit(0);
          }

          // write per-site channels XML
          fs.mkdirSync(path.join('work', CC), { recursive: true });
          const esc = s => String(s)
            .replace(/&/g,'&amp;').replace(/"/g,'&quot;')
            .replace(/</g,'&lt;').replace(/>/g,'&gt;');

          for (const [site, list] of bySite) {
            const outPath = path.join('work', CC, `channels-${CC}-${site}.xml`);
            let xml = '<channels>\n';
            for (const g of list) {
              xml += `  <channel site="${esc(g.site)}" site_id="${esc(g.site_id)}" xmltv_id="${esc(g.channel)}" lang="${esc(g.lang||'en')}"/>\n`;
            }
            xml += '</channels>\n';
            fs.writeFileSync(outPath, xml);
            console.log(`Wrote ${outPath} (${list.length} rows)`);
          }
          NODE

      - name: Grab per-site for ${{ matrix.cc }}
        env:
          CC: ${{ matrix.cc }}
        run: |
          set -e
          mkdir -p out/${CC}
          # run each site separately with its specific config
          for f in work/${CC}/channels-${CC}-*.xml; do
            [ -f "$f" ] || continue
            site=$(basename "$f" .xml | sed -E "s/^channels-${CC}-//")
            cfg="epg-src/sites/${site}/${site}.config.js"
            echo "::group::Grab ${CC} / ${site}"
            echo "using channels: $f"
            echo "using config  : $cfg"
            node epg-src/node_modules/.bin/epg-grabber \
              --config "$cfg" \
              --channels "$f" \
              --output "out/${CC}/${site}.xml" \
              --days 1 \
              --maxConnections 2 \
              --concurrency 2 \
              --timeout 180000 \
              --delay 500 \
              --debug || true
            gzip -f "out/${CC}/${site}.xml" || true
            echo "::endgroup::"
          done
          ls -l out/${CC} || true

      - name: Upload artifact (all site files for ${{ matrix.cc }})
        uses: actions/upload-artifact@v4
        with:
          name: epg-sites-${{ matrix.cc }}
          path: out/${{ matrix.cc }}/**
          if-no-files-found: warn

      # OPTIONAL: Pack and upload a single tar.gz to Supabase
      - name: Tar per-country folder
        run: |
          if [ -d "out/${{ matrix.cc }}" ]; then
            tar czf "out/${{ matrix.cc }}.tar.gz" -C out "${{ matrix.cc }}"
          fi

      - name: Upload to Supabase (optional)
        if: env.SUPABASE_URL != '' && env.SUPABASE_SERVICE_ROLE != ''
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE: ${{ secrets.SUPABASE_SERVICE_ROLE }}
        run: |
          FILE="out/${{ matrix.cc }}.tar.gz"
          if [ -f "$FILE" ]; then
            DEST="epg/${{ matrix.cc }}/${{ matrix.cc }}_${{ github.run_id }}.tar.gz"
            curl -sS -X POST \
              "${SUPABASE_URL}/storage/v1/object/${DEST}" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE}" \
              -H "apikey: ${SUPABASE_SERVICE_ROLE}" \
              -H "x-upsert: true" \
              -H "Content-Type: application/gzip" \
              --data-binary "@${FILE}"
            echo "Uploaded $FILE to $DEST"
          else
            echo "No per-country archive for ${{ matrix.cc }}"
          fi

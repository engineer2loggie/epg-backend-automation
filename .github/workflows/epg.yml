name: EPG
on:
  workflow_dispatch:
  

jobs:
  grab:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      # US removed
      COUNTRIES: PR,MX,CA,IT,ES,GB,AU,IE,DE,DO
      NODE_OPTIONS: --max-old-space-size=2048
      # gatotv.com UNBLOCKED so PR can work
      BLOCKED_SITES: directv.com,mi.tv,tvtv.us,tvpassport.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Prepare repos and snapshots
        run: |
          set -e
          mkdir -p work/api scripts out
          curl -fsSL https://iptv-org.github.io/api/channels.json -o work/api/channels.json
          curl -fsSL https://iptv-org.github.io/api/guides.json   -o work/api/guides.json
          git clone --depth 1 https://github.com/iptv-org/epg epg-src
          npm ci --prefix epg-src

      - name: Write helper scripts
        run: |
          mkdir -p scripts
          cat > scripts/make-channels-by-site.mjs <<'EOF'
          import fs from 'node:fs/promises';
          import path from 'node:path';

          const CC = (process.env.CC || 'US').toUpperCase();
          const API_DIR = 'work/api';
          const OUT_DIR = path.join('work', CC);

          const blocked = new Set(
            (process.env.BLOCKED_SITES || '')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean)
          );

          async function loadJson(p) {
            const buf = await fs.readFile(p, 'utf8');
            return JSON.parse(buf);
          }

          function esc(s) {
            return String(s)
              .replace(/&/g, '&amp;')
              .replace(/"/g, '&quot;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;');
          }

          (async () => {
            await fs.mkdir(OUT_DIR, { recursive: true });

            const channels = await loadJson(path.join(API_DIR, 'channels.json'));
            const guides   = await loadJson(path.join(API_DIR, 'guides.json'));

            const byId = new Map(
              channels
                .filter(c => ((c.country || '').toUpperCase() === CC))
                .map(c => [c.id, c])
            );

            if (byId.size === 0) {
              console.log('[' + CC + '] No channels for this country in channels.json');
              process.exit(0);
            }

            const grouped = new Map(); // site -> Map(site_id -> xmltv_id)
            for (const g of guides) {
              if (!g || !g.channel || !g.site || !g.site_id) continue;
              if (!byId.has(g.channel)) continue;

              const site = String(g.site).trim();
              if (blocked.has(site)) continue;

              if (!grouped.has(site)) grouped.set(site, new Map());
              grouped.get(site).set(String(g.site_id), String(g.channel));
            }

            if (grouped.size === 0) {
              console.log('[' + CC + '] No usable sites (possibly all blocked)');
              process.exit(0);
            }

            for (const [site, map] of grouped) {
              const file = path.join(OUT_DIR, 'channels-' + CC + '-' + site + '.xml');
              const lines = ['<channels>'];
              for (const [site_id, xmltv_id] of map) {
                lines.push(
                  '  <channel site="' + esc(site) + '" site_id="' + esc(site_id) + '" xmltv_id="' + esc(xmltv_id) + '" />'
                );
              }
              lines.push('</channels>');
              lines.push('');
              await fs.writeFile(file, lines.join('\n'), 'utf8');
              console.log('[' + CC + '] wrote ' + file + ' (' + map.size + ' entries)');
            }
          })().catch(err => {
            console.error(err);
            process.exit(1);
          });
          EOF

          cat > scripts/run-grabs.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail

          IFS=',' read -ra CCS <<< "${COUNTRIES}"
          mkdir -p out

          for CC in "${CCS[@]}"; do
            CC="$(echo "$CC" | tr '[:lower:]' '[:upper:]')"
            export CC
            echo "== Prepare channels for ${CC} =="

            node scripts/make-channels-by-site.mjs

            mkdir -p "out/${CC}"
            shopt -s nullglob
            for f in work/${CC}/channels-${CC}-*.xml; do
              site="$(basename "$f" .xml | sed -E "s/^channels-${CC}-//")"
              cfg="epg-src/sites/${site}/${site}.config.js"

              if [[ ! -f "$cfg" ]]; then
                echo "::warning ::No config for site '${site}', skipping (${cfg})"
                continue
              fi

              echo "::group::Grab ${CC} / ${site}"
              echo "channels: $f"
              echo "config   : $cfg"

              set +e
              npm --prefix epg-src run grab --- \
                --site "$site" \
                --channels "$f" \
                --output "out/${CC}/${site}.xml" \
                --days 1 \
                --maxConnections 2 \
                --timeout 180000 \
                --delay 500 \
                2>&1 | tee "out/${CC}/${site}.log"
              rc=${PIPESTATUS[0]}
              set -e

              if [[ -f "out/${CC}/${site}.xml" ]]; then
                gzip -f "out/${CC}/${site}.xml"
                echo "Wrote out/${CC}/${site}.xml.gz"
              else
                echo "::notice ::No XML produced for ${site} (${CC}). See log out/${CC}/${site}.log"
              fi
              echo "::endgroup::"
            done

            if [[ -z "$(ls -A out/${CC} 2>/dev/null || true)" ]]; then
              echo "no site outputs for ${CC}" > "out/${CC}/README.txt"
            fi
          done
          EOF

          chmod +x scripts/run-grabs.sh

      - name: Run grabs
        env:
          COUNTRIES: ${{ env.COUNTRIES }}
          BLOCKED_SITES: ${{ env.BLOCKED_SITES }}
        run: scripts/run-grabs.sh

      - name: Publish to Supabase
        if: always()
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE: ${{ secrets.SUPABASE_SERVICE_ROLE }}
          SUPABASE_DB_TABLE: ${{ secrets.SUPABASE_DB_TABLE }} # optional
        run: |
          set -euo pipefail
          shopt -s nullglob

          if [[ -z "${SUPABASE_URL:-}" || -z "${SUPABASE_SERVICE_ROLE:-}" ]]; then
            echo "Supabase secrets not set; skipping publish."
            exit 0
          fi

          curl -sS -X POST "${SUPABASE_URL}/storage/v1/bucket" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE}" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE}" \
            -H "Content-Type: application/json" \
            -d '{"id":"epg","name":"epg","public":true}' >/dev/null || true

          total=0
          for f in out/*/*.xml.gz; do
            rel="${f#out/}"
            cc="${rel%%/*}"
            site_with_ext="${rel#*/}"
            site="${site_with_ext%.xml.gz}"

            curl -sS -X PUT "${SUPABASE_URL}/storage/v1/object/epg/${cc}/${site}.xml.gz" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE}" \
              -H "apikey: ${SUPABASE_SERVICE_ROLE}" \
              -H "x-upsert: true" \
              -H "Content-Type: application/gzip" \
              --data-binary @"${f}" >/dev/null

            echo "Uploaded ${rel}"
            total=$((total+1))

            if [[ -n "${SUPABASE_DB_TABLE:-}" ]]; then
              size_kb=$(du -k "$f" | cut -f1)
              programs=$(zcat "$f" | grep -c "<programme" || echo 0)
              public_url="${SUPABASE_URL}/storage/v1/object/public/epg/${cc}/${site}.xml.gz"
              curl -sS -X POST "${SUPABASE_URL}/rest/v1/${SUPABASE_DB_TABLE}" \
                -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE}" \
                -H "apikey: ${SUPABASE_SERVICE_ROLE}" \
                -H "Content-Type: application/json" \
                -d "{\"country\":\"${cc}\",\"site\":\"${site}\",\"url\":\"${public_url}\",\"size_kb\":${size_kb},\"programs\":${programs}}" >/dev/null || true
            fi
          done

          echo "Total uploaded: ${total}"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: epg-xml
          path: out/**
          if-no-files-found: warn
